<ui:composition xmlns="http://www.w3.org/1999/xhtml"
                xmlns:h="http://java.sun.com/jsf/html"
                xmlns:f="http://java.sun.com/jsf/core"
                xmlns:ui="http://java.sun.com/jsf/facelets"
                xmlns:p="http://primefaces.org/ui"
                xmlns:c="http://xmlns.jcp.org/jsp/jstl/core">  


    <h:form id="frmWashingMachicneTankProcess" >  
        <ui:include src="/pages/general/common/processtoolbar.xhtml" >
            <ui:param name="outputtext" value="#{loc.tankprocess}"/>
            <ui:param name="bean" value='#{washingMachicneTankTabBean}' />
            <ui:param name="update" value="pgrWashingMachincneTankProcess" />
            <ui:param name="btnSaveId" value="#{washingMachicneTankTabBean.getRendered(246, 0)}" />         
            <ui:param name="btnDeleteId" value="false" />
            <c:if test="#{washingMachicneTankTabBean.processType==2}">
                <ui:param name="btnDeleteId" value="#{washingMachicneTankTabBean.getRendered(247, 0)}" />
                <ui:param name="btnTestBeforeDeleteId" value='true' />
            </c:if>
        </ui:include>

        <h:panelGroup id="pgrWashingMachincneTankProcess" layout="block">
            <div class="ui-g-12 divContent"> 
                <div class="ui-g-12 ">
                    <div class="ui-g-12 ui-md-6 ui-lg-6">
                        <p:outputLabel value="#{loc.tankno}" for="txtTankNo" styleClass="Fs12 FontBold"/>
                        <p:inputText id="txtTankNo" value="#{washingMachicneTankTabBean.selectedObject.tankNo}" styleClass="Wid95" required="true" placeholder="#{loc.tankno} "/>
                    </div>

                    <div class="ui-g-12 ui-md-6 ui-lg-6">     
                        <p:outputLabel value="#{loc.stock}" for="txtStock" class="Fs12 FontBold"/>
                        <p:inputText id="txtStock" value="#{washingMachicneTankTabBean.selectedObject.stock.name}" onclick="showBook()" class="inputPositionForBookFilter" required="true" readonly="#{facesContext.currentPhaseId.ordinal ge 4}"  placeholder="#{loc.stock} ">
                        </p:inputText>
                        <p:commandLink id="btnStock" class="commandLinkPositionForBookFilter" process="@this" oncomplete="PF('olp_stock').loadContents();" >
                            <i class="fa fa-book Fs16 softgray iconPositionForBookFilter "/>   
                            <p:ajax listener="#{stockBookFilterBean.findFilterListLazyLoading([],'frmStockBookFilter','olp_stock','washingmachineservice')}"  />
                        </p:commandLink>
                    </div> 


                    <div class="ui-g-12 ui-md-6 ui-lg-4">
                        <p:outputLabel value="#{loc.capacity}" for="txtCapaxity"  styleClass="Fs12 FontBold"/>
                        <p:inputNumber id="txtCapaxity" value="#{washingMachicneTankTabBean.selectedObject.capacity}" minValue="1"
                                       decimalSeparator="#{sessionBean.user.lastBranch.decimalsymbol==1? '.': ','}"  
                                       thousandSeparator="#{sessionBean.user.lastBranch.decimalsymbol==1? ',': '.'}" emptyValue="sign"
                                       roundMethod="D"  required="true"
                                       symbol="#{washingMachicneTankTabBean.selectedObject.stock.unit.sortName}"
                                       symbolPosition="#{sessionBean.locale=='tr' ? 's': 'p'}"
                                       class="Wid90 TexAlRight" placeholder="#{loc.capacity}" >                 
                        </p:inputNumber>
                    </div>

                    <div class="ui-g-12 ui-md-6 ui-lg-4">
                        <p:outputLabel value="#{loc.availablequantity}" for="txtBalance"  styleClass="Fs12 FontBold" style="white-space: pre"/>
                        <p:inputNumber id="txtBalance" value="#{washingMachicneTankTabBean.selectedObject.balance}" minValue="0"
                                       decimalSeparator="#{sessionBean.user.lastBranch.decimalsymbol==1? '.': ','}"  
                                       thousandSeparator="#{sessionBean.user.lastBranch.decimalsymbol==1? ',': '.'}" emptyValue="sign"
                                       roundMethod="D" decimalPlaces="#{sessionBean.user.lastBranch.currencyrounding}"
                                       symbol="#{washingMachicneTankTabBean.selectedObject.stock.unit.sortName}"
                                       symbolPosition="#{sessionBean.locale=='tr' ? 's': 'p'}" required="true"
                                       class="Wid90 TexAlRight" placeholder="#{loc.availablequantity}" >                 
                        </p:inputNumber> 
                    </div>

                    <div class="ui-g-12 ui-md-6 ui-lg-4">
                        <p:outputLabel value="#{loc.mincapacity}" for="txtMinCapacity"  styleClass="Fs12 FontBold" style="white-space: pre"/>
                        <p:inputNumber id="txtMinCapacity" value="#{washingMachicneTankTabBean.selectedObject.minCapacity}" minValue="0"
                                       decimalSeparator="#{sessionBean.user.lastBranch.decimalsymbol==1? '.': ','}"  
                                       thousandSeparator="#{sessionBean.user.lastBranch.decimalsymbol==1? ',': '.'}" emptyValue="sign"
                                       roundMethod="D"  required="true"
                                       symbol="#{washingMachicneTankTabBean.selectedObject.stock.unit.sortName}"
                                       symbolPosition="#{sessionBean.locale=='tr' ? 's': 'p'}"
                                       class="Wid90 TexAlRight" placeholder="#{loc.mincapacity}" >                 
                        </p:inputNumber>
                    </div>
                </div>


                <h:panelGroup id="test" rendered="#{washingMachicneTankTabBean.processType==2}">
                    <div class="ui-g-12" style="height: 220px">  
                        <div class="ui-g-6 ui-md-6" >
                            <svg id="fillgauge1" width="97%" height="250"></svg>
                        </div> 

                        <div class="ui-g-6 ui-md-6" >
                            <table style="visibility: hidden;">
                                <tbody>
                                    <tr>
                                        <td style="color:#376c97">#{loc.capacity}</td>
                                    </tr>
                                    <tr>
                                        <td style="color:#376c97">#{loc.availablequantity}</td>
                                    </tr>
                                    <tr>
                                        <td style="color:#376c97">#{loc.mincapacity}</td>
                                    </tr>
                                </tbody>
                            </table>

                            <table>
                                <tbody>
                                    <tr>
                                        <td style="color:#376c97;font-size: 13px">#{loc.capacity}</td>
                                        <td class="TexAlRight" style="vertical-align: center;"> 
                                            <h:outputText value="#{washingMachicneTankTabBean.selectedObject.capacity}" class="Fright Fs14 FontBold" >
                                                <f:converter converterId="currencyConverter"  />
                                                <f:attribute name="unit"  value="#{washingMachicneTankTabBean.selectedObject.stock.unit}"/>
                                                <f:attribute name="type" value="unit" />
                                            </h:outputText>


                                        </td>
                                    </tr>
                                    <tr>
                                        <td style="color:#376c97;font-size: 13px">#{loc.availablequantity}</td>
                                        <td style="vertical-align: center;" class="TexAlRight">    <h:outputText value="#{washingMachicneTankTabBean.selectedObject.balance}"  class="Fright Fs14 FontBold" >
                                                <f:converter converterId="currencyConverter"  />
                                                <f:attribute name="unit"  value="#{washingMachicneTankTabBean.selectedObject.stock.unit}"/>
                                                <f:attribute name="type" value="unit" />
                                            </h:outputText>
                                        </td>

                                    </tr>
                                    <tr>
                                        <td style="color:#376c97;font-size: 13px">#{loc.mincapacity}</td>
                                        <td style="vertical-align: center;" class="TexAlRight">    <h:outputText value="#{washingMachicneTankTabBean.selectedObject.capacity}"  class="Fright Fs14 FontBold" >
                                                <f:converter converterId="currencyConverter"  />
                                                <f:attribute name="unit"  value="#{washingMachicneTankTabBean.selectedObject.stock.unit}"/>
                                                <f:attribute name="type" value="unit" />
                                            </h:outputText>
                                        </td>
                                    </tr>
                                </tbody>
                            </table>

                        </div>
                    </div>
                </h:panelGroup>
            </div>
            <p:remoteCommand name="showBook" process="@this" oncomplete="PF('olp_stock').loadContents()" actionListener="#{stockBookFilterBean.findFilterListLazyLoading([],'frmStockBookFilter','olp_stock','washingmachineservice')}" />

        </h:panelGroup>
    </h:form>

    <!-- stok listesinde kitaba basıldığında stokların listendiği dialog-->
    <ui:include src="/pages/general/common/stockbook.xhtml" >
        <ui:param name="updateBean" value='#{washingMachicneTankTabBean}' />
        <ui:param name="for" value='frmWashingMachicneTankProcess:btnStock' />
        <ui:param name="type" value="washingmachineservice" />
        <ui:param name="parameters" value='#{[]}' /> 
        <ui:param name="columnsize" value='2' />
        <ui:param name="form" value='frmStockBookFilter' /> 
        <ui:param name="overlay" value="olp_stock" />
    </ui:include>

    <style>
        .capitalized {
            text-transform: capitalize;
        }
        .svg-container {
            display: inline-block;
            position: relative;
            width: 100%;
            padding-bottom: 100%; /* aspect ratio */
        }
        .svg-content-responsive {
            display: inline-block;
            position: absolute;
        }
    </style>


    <script type="text/javascript">
        //<![CDATA[
        function liquidFillGaugeDefaultSettings(value, min, max, textcolor, circlecolor, wavecolor) {
            return {
                minValue: min == null ? 0 : min, // Tank min kapasite
                maxValue: max == null ? 100 : max, //Tank Max Kapasite
                circleThickness: 0.05, //Dış daire kalınlığı yarıçapı yüzdesi olarak.
                circleFillGap: 0.05, //Dış daire yarıçapının yüzdesi olarak dış daire ve dalga daire arasındaki boşluğun boyutu.
                circleColor: circlecolor == null ? "#002344" : circlecolor, // Dış dairenin rengi lacivert
                waveHeight: 0.05, // Dalga yüksekliği.kıvırımlar
                waveCount: 3, // Dalga çemberinin genişliği başına tam dalgaların sayısı.
                waveRiseTime: 2500, // Dalganın 0'dan son yüksekliğine yükselmesi için geçen süre milisaniyedir.
                waveAnimateTime: 1000, // Tam bir dalganın dalga dairesine girmesi için geçen süre milisaniye cinsindendir.
                waveRise: true, // Dalga 0'dan tam yüksekliğe yükselmeli mi, yoksa tam yükseklikte mi başlayacağını kontrol et.
                waveHeightScaling: true, // Düşük ve yüksek dolum yüzdelerinde dalga boyutu ölçeklendirmesini kontrol eder. Doğru olduğunda, dalga yüksekliği en fazla% 50 dolulukta ve en az% 0 ve% 100 dolumda ulaşır. Bu, minimum veya maksimum dolumun yakınında dalganın dalga çemberinin tamamen dolu veya boş görünmesini önlemeye yardımcı olur.

                waveAnimate: true, // Dalganın kayar veya statik olup olmadığını kontrol eder.
                waveColor: wavecolor == null ? "red" : wavecolor, // İç dalga rengi
                waveOffset: 0.50, //İlk önce dalgayı dengeleme miktarı. 0 = ofset yok. 1 = bir tam dalganın kayması.

                textVertPosition: .8, //  yüzde metninin görüntüleneceği yükseklik. 0 = alt, 1 = üst.
                textSize: 0.5, // yazı boyutu. 1 = 50%
                valueCountUp: true, // Yüzde yazısı artarak gelir.False yüzde yazısı sabittir
                displayPercent: true, // değerin yanında yüzde işareti görüntülensin mi 
                textColor: textcolor == null ? "red" : textcolor, // dolum miktarının yazısı
                waveTextColor: "white" // 
            };
        }

        function loadtankfill(elementId, value, min, max, textcolor, circlecolor, wavecolor) {
            var config;
            if (config == null)
                config = liquidFillGaugeDefaultSettings(value, min, max, textcolor, circlecolor, wavecolor);
            var gauge = d3.select("#" + elementId);
            var radius = Math.min(parseInt(gauge.style("width")), parseInt(gauge.style("height"))) / 3;
            var locationX = parseInt(gauge.style("width")) / 2 - radius;
            var locationY = parseInt(gauge.style("height")) / 2 - radius;
            var fillPercent = Math.max(config.minValue, Math.min(config.maxValue, value)) / config.maxValue;

            var waveHeightScale;
            if (config.waveHeightScaling) {
                waveHeightScale = d3.scale.linear()
                        .range([0, config.waveHeight, 0])
                        .domain([0, 50, 100]);
            } else {
                waveHeightScale = d3.scale.linear()
                        .range([config.waveHeight, config.waveHeight])
                        .domain([0, 100]);
            }

            var textPixels = (config.textSize * radius / 2);
            var textFinalValue = parseFloat((value * 100) / max).toFixed(2);
            var textStartValue = config.valueCountUp ? config.minValue : textFinalValue;
            var percentText = config.displayPercent ? "%" : "";
            var circleThickness = config.circleThickness * radius;
            var circleFillGap = config.circleFillGap * radius;
            var fillCircleMargin = circleThickness + circleFillGap;
            var fillCircleRadius = radius - fillCircleMargin;
            var waveHeight = fillCircleRadius * waveHeightScale(fillPercent * 100);

            var waveLength = fillCircleRadius * 2 / config.waveCount;
            var waveClipCount = 1 + config.waveCount;
            var waveClipWidth = waveLength * waveClipCount;

            // Rounding functions so that the correct number of decimal places is always displayed as the value counts up.
            var textRounder = function (value) {
                return Math.round(value);
            };
            if (parseFloat(textFinalValue) != parseFloat(textRounder(textFinalValue))) {
                textRounder = function (value) {
                    return parseFloat(value).toFixed(1);
                };
            }
            if (parseFloat(textFinalValue) != parseFloat(textRounder(textFinalValue))) {
                textRounder = function (value) {
                    return parseFloat(value).toFixed(2);
                };
            }

            // Data for building the clip wave area.
            var data = [];
            var totall = 40 * waveClipCount;
            for (var i = 0; i <= totall; i++) {
                data.push({
                    x: i / (40 * waveClipCount),
                    y: (i / (40))
                });
            }

            // Scales for drawing the outer circle.
            var gaugeCircleX = d3.scale.linear().range([0, 2 * Math.PI]).domain([0, 1]);
            var gaugeCircleY = d3.scale.linear().range([0, radius]).domain([0, radius]);

            // Scales for controlling the size of the clipping path.
            var waveScaleX = d3.scale.linear().range([0, waveClipWidth]).domain([0, 1]);
            var waveScaleY = d3.scale.linear().range([0, waveHeight]).domain([0, 1]);

            // Scales for controlling the position of the clipping path.
            var waveRiseScale = d3.scale.linear()
                    // The clipping area size is the height of the fill circle + the wave height, so we position the clip wave
                    // such that the it will won't overlap the fill circle at all when at 0%, and will totally cover the fill
                    // circle at 100%.
                    .range([(fillCircleMargin + fillCircleRadius * 2 + waveHeight), (fillCircleMargin - waveHeight)])
                    .domain([0, 1]);
            var waveAnimateScale = d3.scale.linear()
                    .range([0, waveClipWidth - fillCircleRadius * 2]) // Push the clip area one full wave then snap back.
                    .domain([0, 1]);

            // Scale for controlling the position of the text within the gauge.
            var textRiseScaleY = d3.scale.linear()
                    .range([fillCircleMargin + fillCircleRadius * 2, (fillCircleMargin + textPixels * 0.7)])
                    .domain([0, 1]);

            // Center the gauge within the parent SVG.
            var gaugeGroup = gauge.append("g")
                    .attr('transform', 'translate(' + locationX + ',' + locationY + ')');

            // Draw the outer circle.
            var gaugeCircleArc = d3.svg.arc()
                    .startAngle(gaugeCircleX(0))
                    .endAngle(gaugeCircleX(1))
                    .outerRadius(gaugeCircleY(radius))
                    .innerRadius(gaugeCircleY(radius - circleThickness));
            gaugeGroup.append("path")
                    .attr("d", gaugeCircleArc)
                    .style("fill", config.circleColor)
                    .attr('transform', 'translate(' + radius + ',' + radius + ')');

            // Text where the wave does not overlap.
            var text1 = gaugeGroup.append("text")
                    .text(textRounder(textStartValue) + percentText)
                    .attr("class", "liquidFillGaugeText")
                    .attr("text-anchor", "middle")
                    .attr("font-size", textPixels + "px")
                    .style("fill", config.textColor)
                    .attr('transform', 'translate(' + radius + ',' + textRiseScaleY(config.textVertPosition) + ')');

            // The clipping wave area.
            var clipArea = d3.svg.area()
                    .x(function (d) {
                        return waveScaleX(d.x);
                    })
                    .y0(function (d) {
                        return waveScaleY(Math.sin(Math.PI * 2 * config.waveOffset * -1 + Math.PI * 2 * (1 - config.waveCount) + d.y * 2 * Math.PI));
                    })
                    .y1(function (d) {
                        return (fillCircleRadius * 2 + waveHeight);
                    });
            var waveGroup = gaugeGroup.append("defs")
                    .append("clipPath")
                    .attr("id", "clipWave" + elementId);
            var wave = waveGroup.append("path")
                    .datum(data)
                    .attr("d", clipArea);

            // The inner circle with the clipping wave attached.
            var fillCircleGroup = gaugeGroup.append("g")
                    .attr("clip-path", "url(#clipWave" + elementId + ")");
            fillCircleGroup.append("circle")
                    .attr("cx", radius)
                    .attr("cy", radius)
                    .attr("r", fillCircleRadius)
                    .style("fill", config.waveColor);

            // Text where the wave does overlap.
            var text2 = fillCircleGroup.append("text")
                    .text(textRounder(textStartValue) + percentText)
                    .attr("class", "liquidFillGaugeText")
                    .attr("text-anchor", "middle")
                    .attr("font-size", textPixels + "px")
                    .style("fill", config.waveTextColor)
                    .attr('transform', 'translate(' + radius + ',' + textRiseScaleY(config.textVertPosition) + ')');

            // Make the value count up.
            if (config.valueCountUp) {
                var textTween = function () {
                    var i = d3.interpolate(this.textContent, textFinalValue);
                    return function (t) {
                        this.textContent = textRounder(i(t)) + percentText;
                    }
                };
                text1.transition()
                        .duration(config.waveRiseTime)
                        .tween("text", textTween);
                text2.transition()
                        .duration(config.waveRiseTime)
                        .tween("text", textTween);
            }

            // Make the wave rise. wave and waveGroup are separate so that horizontal and vertical movement can be controlled independently.
            var waveGroupXPosition = fillCircleMargin + fillCircleRadius * 2 - waveClipWidth;
            if (config.waveRise) {
                waveGroup.attr('transform', 'translate(' + waveGroupXPosition + ',' + waveRiseScale(0) + ')')
                        .transition()
                        .duration(config.waveRiseTime)
                        .attr('transform', 'translate(' + waveGroupXPosition + ',' + waveRiseScale(fillPercent) + ')')
                        .each("start", function () {
                            wave.attr('transform', 'translate(1,0)');
                        }); // This transform is necessary to get the clip wave positioned correctly when waveRise=true and waveAnimate=false. The wave will not position correctly without this, but it's not clear why this is actually necessary.
            } else {
                waveGroup.attr('transform', 'translate(' + waveGroupXPosition + ',' + waveRiseScale(fillPercent) + ')');
            }

            if (config.waveAnimate)
                animateWave();

            function animateWave() {
                wave.transition()
                        .duration(config.waveAnimateTime)
                        .ease("linear")
                        .attr('transform', 'translate(' + waveAnimateScale(1) + ',0)')
                        .each("end", function () {
                            wave.attr('transform', 'translate(' + waveAnimateScale(0) + ',0)');
                            animateWave(config.waveAnimateTime);
                        });
            }

        }
        //]]>

    </script>


</ui:composition>